---
description: Python Type Annotations Best Practices
globs: *.py
alwaysApply: true
---
# Python Type Annotations Best Practices

This rule provides guidance on how to use type annotations effectively in modern Python code.

## Introduction

Type hints in Python help with code quality, IDE assistance, and static type checking. Following these best practices will help make your code more maintainable and future-proof.

## Modern Type Annotations

### Use Built-in Generics Instead of Typing Aliases

Modern Python allows using built-in container types directly as generics, rather than importing them from the `typing` module.

❌ **Deprecated:**
```python
from typing import List, Dict, Tuple, Set

def process_items(items: List[str]) -> Dict[str, int]:
    ...
```

✅ **Modern:**
```python
def process_items(items: list[str]) -> dict[str, int]:
    ...
```

### Direct Replacements for Typing Module Imports

**It is essential to replace the following deprecated types from the `typing` module with their modern, built-in equivalents for improved code readability, maintainability, and compatibility with newer Python versions.**

| Deprecated (typing) | Modern Equivalent |
|---------------------|------------------|
| `List[X]`           | `list[X]`        |
| `Dict[X, Y]`        | `dict[X, Y]`     |
| `Tuple[X, Y]`       | `tuple[X, Y]`    |
| `Set[X]`            | `set[X]`         |
| `FrozenSet[X]`      | `frozenset[X]`   |
| `Type[X]`           | `type[X]`        |

**Failure to replace these deprecated types may result in code that is harder to understand and maintain, and may not be compatible with future versions of Python.**

### Collections Abstract Base Classes

For abstract collection types, import from collections.abc instead of typing:

❌ **Deprecated:**
```python
from typing import Iterable, Mapping, Sequence

def process_sequence(seq: Sequence[int]) -> None:
    ...
```

✅ **Modern:**
```python
from collections.abc import Iterable, Mapping, Sequence

def process_sequence(seq: Sequence[int]) -> None:
    ...
```

## Shorthand Syntax

### Union Types

Use the pipe (`|`) syntax for union types instead of `Union`:

❌ **Deprecated:**
```python
from typing import Union

def process_input(data: Union[str, int]) -> None:
    ...
```

✅ **Modern:**
```python
def process_input(data: str | int) -> None:
    ...
```

### Optional Types

Use `| None` instead of `Optional`:

❌ **Deprecated:**
```python
from typing import Optional

def get_value(key: str) -> Optional[int]:
    ...
```

✅ **Modern:**
```python
def get_value(key: str) -> int | None:
    ...
```

Note: When using union with `None`, always place `None` as the last element in the union.

## Type Aliases

Use `TypeAlias` for type aliases (but not for regular aliases):

```python
from typing import TypeAlias

# Type alias - use TypeAlias
IntList: TypeAlias = list[int]

# Regular alias - don't use TypeAlias
Path = pathlib.Path
ERROR = errno.EEXIST
```

## Arguments and Return Types

### Arguments

Prefer protocols and abstract types for arguments:

```python
from collections.abc import Iterable, Mapping

# Good - accepts any iterable
def process_items(items: Iterable[str]) -> list[str]:
    ...
    
# Less flexible - only accepts lists
def process_items_restrictive(items: list[str]) -> list[str]:
    ...
```

### Return Types

Prefer concrete types for return values:

```python
# Good - returns a concrete type
def fetch_data() -> dict[str, int]:
    ...
    
# Less clear - returns an abstract type
def fetch_data_abstract() -> Mapping[str, int]:
    ...
```

## Using `Any` vs `object`

- Use `Any` when a type cannot be expressed appropriately or using the correct type is unergonomic
- Use `object` when a function accepts any possible object:

```python
# Use object when accepting any value but not treating it as having arbitrary attributes
def to_string(o: object) -> str:
    return str(o)
    
# Use Any when you need to treat a value as having arbitrary attributes
def process_dynamic(data: Any) -> None:
    data.any_method()  # No type error
```

## Additional Tips

### Float vs Int | Float

Use `float` instead of `int | float` when a parameter can accept either type.

### None vs Literal[None]

Use `None` instead of `Literal[None]`.

### Avoiding Union Return Types

Avoid union return types where possible, as they require `isinstance()` checks. Use `Any` or `X | Any` if necessary.

## Example of Modern Type Annotations

```python
from collections.abc import Mapping, Sequence, Iterable
from typing import TypeAlias, Any

# Type alias
JsonDict: TypeAlias = dict[str, str | int | float | bool | None | list[Any] | dict[str, Any]]

def process_data(items: Sequence[int], config: Mapping[str, str | int] | None = None) -> list[str]:
    """
    Process a sequence of integers using an optional configuration.
    
    Args:
        items: The sequence of integers to process
        config: Optional configuration parameters
        
    Returns:
        A list of formatted strings
    """
    result = []
    for item in items:
        # Processing logic
        result.append(str(item))
    return result
```
```
