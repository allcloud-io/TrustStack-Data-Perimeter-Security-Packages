---
description: Python Documentation Strings Best-Practices
globs: *.py
alwaysApply: true
---
# Python Documentation Strings Best-Practices

This rule provides guidance on how to write effective Python docstrings following the Google Python Style Guide.

## Introduction

Python uses docstrings to document code. A docstring is a string that is the first statement in a package, module, class, or function. These strings can be extracted automatically through the `__doc__` member of the object and are used by tools like `pydoc`.

## General Docstring Rules

- Always use the three double-quote `"""` format for docstrings (per PEP 257)
- A docstring should be organized as a summary line (one physical line not exceeding 80 characters) terminated by a period, question mark, or exclamation point
- When writing more (encouraged), this must be followed by a blank line, followed by the rest of the docstring starting at the same cursor position as the first quote of the first line
- Use descriptive style (`"""Fetches rows from a Bigtable."""`) rather than imperative style (`"""Fetch rows from a Bigtable."""`)
- For `@property` decorators, use the same style as attributes (descriptive, not imperative)

## Module Docstrings

Every Python file should start with a docstring describing the contents and usage of the module:

```python
"""A one-line summary of the module or program, terminated by a period.

Leave one blank line. The rest of this docstring should contain an
overall description of the module or program. Optionally, it may also
contain a brief description of exported classes and functions and/or usage
examples.

Typical usage example:

  foo = ClassFoo()
  bar = foo.function_bar()
"""
```

### Test Modules

Module-level docstrings for test files are not required. They should be included only when there is additional information that can be provided, such as:
- Specifics on how the test should be run
- Explanation of an unusual setup pattern
- Dependency on the external environment

## Function and Method Docstrings

A docstring is mandatory for every function that has one or more of the following properties:
- Being part of the public API
- Nontrivial size
- Non-obvious logic

A function docstring should give enough information to write a call to the function without reading the function's code. The docstring should describe the function's calling syntax and its semantics, not its implementation details, unless those details are relevant to how the function is to be used.

### Function Docstring Format

```python
def function_name(param1, param2, param3=None):
    """Summary of function purpose and behavior.

    More detailed explanation of function behavior, if needed.
    Include any external effects this function has.

    Args:
        param1 (type): Description of param1. Type can be omitted if using
            type annotations.
        param2 (type): Description of param2. Descriptions can span multiple
            lines with indentation maintained.
        param3 (type, optional): Description of optional param3, default is None.
            Note the optional label for optional parameters.

    Returns:
        type: Description of the return value.
        If the function returns multiple values, document each in a separate
        line with the same format as a parameter.

    Raises:
        ExceptionType: When and why this exception is raised.
        AnotherExceptionType: Under what conditions this is raised.

    Examples:
        Examples should be included for complex functions. Code examples
        should be runnable:

        >>> function_name('example', 'foo')
        'Expected output'
    """
```

### Special Sections

Certain aspects of a function should be documented in special sections:

- **Args**: List each parameter by name with type (if not using type annotations) and description
- **Returns**: What the function returns
- **Raises**: All exceptions that are relevant to the interface
- **Examples**: Include examples for complex functions

### Variable Length Arguments

If a function accepts `*args` (variable length argument lists) and/or `**kwargs` (arbitrary keyword arguments), they should be listed as `*args` and `**kwargs` in the Args section.

### Overridden Methods

A method that overrides a method from a base class may have a simple docstring sending the reader to its overridden method's docstring, such as `"""See base class."""`. However, if the overriding method's behavior is substantially different from the overridden method, or details need to be provided, a docstring with at least those differences is required.

## Class Docstrings

Classes should have a docstring below the class definition describing the class:

```python
class SampleClass:
    """Summary of class here.

    Longer class information...
    Longer class information...

    Attributes:
        likes_spam: A boolean indicating if we like SPAM or not.
        eggs: An integer count of the eggs we have laid.
    """
```

### Class Docstring Format

- All class docstrings should start with a one-line summary that describes what the class instance represents
- Public attributes, excluding properties, should be documented in an `Attributes` section and follow the same formatting as a function's Args section
- The class docstring should not repeat unnecessary information, such as that the class is a class

### Exception Classes

Subclasses of `Exception` should describe what the exception represents, not the context in which it might occur:

```python
# Yes:
class OutOfCheeseError(Exception):
    """No more cheese is available."""

# No:
class OutOfCheeseError(Exception):
    """Raised when no more cheese is available."""
```

## Properties

For properties, use the same style as attributes (descriptive, not imperative):

```python
@property
def butter_sticks(self) -> int:
    """The number of butter sticks we have."""
    return self._butter_sticks
```

## Type Annotations and Docstrings

When using type annotations (PEP 484), you don't need to duplicate type information in the docstring:

```python
def function_with_pep484_type_annotations(param1: int, param2: str) -> bool:
    """Example function with PEP 484 type annotations.

    Args:
        param1: The first parameter.
        param2: The second parameter.

    Returns:
        The return value. True for success, False otherwise.
    """
```

## Best Practices

1. **Be Descriptive**: Docstrings should describe what the function/class does, not how it does it
2. **Maintain Consistency**: Use the same docstring style throughout your codebase
3. **Include Examples**: For complex functions, include examples of usage
4. **Document Side Effects**: If a function modifies its arguments or has other side effects, document this clearly
5. **Pay Attention to Grammar**: Use proper punctuation, spelling, and grammar
6. **Keep It Updated**: When code changes, update the docstrings to match

## Examples

### Module Example

```python
"""Database client for accessing the user records.

This module provides a client interface for accessing and modifying user
records in the database. It handles connection pooling, retries, and
proper escaping of user input.

Typical usage example:

  db = DatabaseClient()
  user = db.get_user_by_email('user@example.com')
  user.update_last_login()
  db.save_user(user)
"""
```

### Function Example

```python
def fetch_bigtable_rows(big_table, start_key, end_key, max_rows=1000):
    """Fetches rows from a Bigtable table.

    Retrieves rows from the table. Rows will be streamed in yield fashion,
    in key order.

    Args:
        big_table: An open Bigtable Table instance.
        start_key: String key to start reading at, inclusive.
        end_key: String key to stop reading at, inclusive.
        max_rows: The maximum number of rows to return (int).

    Returns:
        A generator that yields tuples of (row_key, row_data).

    Raises:
        ConnectionError: If the connection to the database fails.
        ValueError: If start_key is greater than end_key.
    """
```

### Class Example

```python
class UserAccount:
    """A user account in the system.

    This class represents a user account with authentication and profile
    information. It provides methods for managing the user's data and
    permissions.

    Attributes:
        username: The user's username (str).
        email: The user's email address (str).
        is_active: Whether the account is active (bool).
        date_joined: When the user joined (datetime).
    """

    def __init__(self, username, email):
        """Initialize a new user account.

        Args:
            username: The user's chosen username.
            email: The user's email address.
        """
        self.username = username
        self.email = email
        self.is_active = True
        self.date_joined = datetime.now()
```